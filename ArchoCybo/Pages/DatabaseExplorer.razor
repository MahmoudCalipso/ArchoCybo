@page "/database"
@attribute [Authorize]
@using System.Net.Http.Json
@using Microsoft.AspNetCore.Components.Web
@using Microsoft.JSInterop
@using Microsoft.AspNetCore.SignalR.Client
@using System.Text.Json
@using Microsoft.AspNetCore.Authorization
@using MudBlazor
@inject HttpClient Http
@inject NavigationManager Nav
@inject IJSRuntime JS

<style>
  /* Prisma Studio-like minimal theme */
  .explorer-root { padding:18px; font-family: Inter,system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial; background: #f6f7fb; min-height: calc(100vh - 72px); }
  .toolbar { display:flex; gap:10px; align-items:center; margin-bottom:12px; }
  .panel { display:flex; gap:16px; }
  .canvas-card { flex:1; background:linear-gradient(180deg,#fff,#fbfdff); border-radius:12px; padding:16px; box-shadow:0 6px 18px rgba(10,12,25,0.06); min-height:640px; position:relative; overflow:hidden; }
  .sidebar { width:320px; display:flex; flex-direction:column; gap:12px; }
  .node {
    position:absolute; width:220px; background:#fff; border-radius:10px; padding:10px;
    box-shadow:0 8px 20px rgba(14,20,40,0.06); border:1px solid #e7eefc; cursor:grab; user-select:none;
    transition: box-shadow .12s;
  }
  .node:active { cursor:grabbing; }
  .node-title { font-weight:600; font-size:14px; color:#0f172a; margin-bottom:6px; display:flex; justify-content:space-between; align-items:center; }
  .node-fields { font-size:13px; color:#475569; max-height:120px; overflow:auto; margin-top:6px; }
  .svg-lines { position:absolute; left:0; top:0; pointer-events:none; }
  .control-btn { padding:8px 10px; border-radius:8px; border:1px solid #e6eefc; background:white; cursor:pointer; }
  .control-btn.primary { background:#0ea5a0; color:white; border:none; }
  .status { font-size:13px; color:#6b7280; }
  .selected { box-shadow:0 10px 28px rgba(14,20,40,0.12); border-color:#c7e6e3; }
  .small-muted { font-size:12px; color:#94a3b8; }
  .sidebar-card { background:white; padding:12px; border-radius:10px; box-shadow:0 8px 18px rgba(11,15,26,0.04); }
  .muted { color:#6b7280; font-size:13px; }
  .action-row { display:flex; gap:8px; margin-top:8px; flex-wrap:wrap; }
  .mode-badge { padding:6px 8px; border-radius:8px; background:#eef2ff; font-size:13px; color:#2563eb; }
  .json-area { width:100%; height:160px; font-family:monospace; font-size:13px; padding:8px; border-radius:8px; border:1px solid #e6eefc; background:#fbfdff; }
  .footer-legend { margin-top:10px; font-size:13px; color:#64748b; }
</style>

<div class="explorer-root">
  <div class="toolbar">
    <MudText Typo="Typo.h5">Database Explorer (Graph)</MudText>

    <div style="flex:1"></div>

    <button class="control-btn" @onclick="ResetPositions">Reset Layout</button>
    <button class="control-btn" @onclick="ImportModelPrompt">Import JSON</button>
    <button class="control-btn" @onclick="ExportModel">Export JSON</button>
    <button class="control-btn primary" @onclick="AddEntity">+ New Entity</button>

    <div style="width:8px"></div>
    <div class="mode-badge">@((addRelationMode ? "Relation: Select source ? target" : "Navigate"))</div>
  </div>

  <div class="panel">
    <div class="canvas-card" @onpointermove="OnPointerMove" @onpointerup="OnPointerUp" @onpointercancel="OnPointerUp" @ref="canvasRef">
      <!-- SVG lines -->
      <svg class="svg-lines" style="width:100%; height:100%;" @ref="svgRef">
        @foreach (var r in relations)
        {
          var sCenter = GetCenter(r.Source);
          var tCenter = GetCenter(r.Target);
          <line x1="@sCenter.X" y1="@sCenter.Y" x2="@tCenter.X" y2="@tCenter.Y" stroke="#c7e7ff" stroke-width="2" stroke-linecap="round" />
        }
      </svg>

      <!-- nodes -->
      @foreach (var e in graphEntities)
      {
        var css = $"left:{e.X}px; top:{e.Y}px;";
        var cls = e.Name == selectedNodeName ? "node selected" : "node";
        <div class="@cls" style="@css"
             @onpointerdown="@((PointerEventArgs ev) => OnNodePointerDown(ev, e.Name))"
             @onclick="@(() => OnNodeClick(e.Name))">
          <div class="node-title">
            <span>@e.Name</span>
            <small class="small-muted">@e.Fields?.Count ?? 0</small>
          </div>
          <div class="node-fields">
            @if (e.Fields != null && e.Fields.Count>0)
            {
              foreach (var f in e.Fields.Take(8))
              {
                <div>@f.Name : <span class="muted">@f.Type</span></div>
              }
              if (e.Fields.Count > 8)
              {
                <div class="small-muted">... @((e.Fields.Count-8)) more</div>
              }
            }
            else
            {
              <div class="small-muted">No columns loaded</div>
            }
          </div>
        </div>
      }
    </div>

    <div class="sidebar">
      <div class="sidebar-card">
        <h4>Selected</h4>
        @if (selectedNodeName != null)
        {
          <div><b>@selectedNodeName</b></div>
          <div class="muted">Columns: @((graphEntities.FirstOrDefault(x=>x.Name==selectedNodeName)?.Fields?.Count ?? 0))</div>

          <div style="margin-top:8px">
            <MudButton Variant="Variant.Text" OnClick="LoadColumnsForSelected">Load Columns</MudButton>
            <MudButton Variant="Variant.Text" OnClick="DeleteSelectedEntity" Color="Color.Error">Delete</MudButton>
          </div>

          <div style="margin-top:12px">
            <h5 class="small-muted">Columns (live)</h5>
            @if (selectedColumns != null)
            {
              <div style="max-height:200px; overflow:auto;">
                <table style="width:100%; border-collapse:collapse;">
                  @foreach (var c in selectedColumns)
                  {
                    <tr><td style="padding:6px; border-bottom:1px solid #f1f5f9;">@c.GetProperty("Name").GetString()</td><td style="padding:6px; border-bottom:1px solid #f1f5f9;">@c.GetProperty("Type").GetString()</td></tr>
                  }
                </table>
              </div>
            }
            else
            {
              <div class="small-muted">Columns are not loaded — click 'Load Columns' to fetch.</div>
            }
          </div>
        }
        else
        {
          <div class="small-muted">No entity selected. Click a node to view details.</div>
        }
      </div>

      <div class="sidebar-card">
        <h4>Relations</h4>
        <div class="action-row">
          <button class="control-btn" @onclick="ToggleAddRelation">@((addRelationMode) ? "Cancel Relation" : "Add Relation")</button>
          <button class="control-btn" @onclick="ClearRelations">Clear All</button>
        </div>
        <div style="margin-top:10px">
          @if (relations.Count == 0)
          { 
              <div class="small-muted">No relations</div>

          } else
          {
            <ol>
              @for (int i=0;i<relations.Count;i++)
              {
                var r = relations[i];
                <li>@r.Source ? @r.Target <button class="control-btn" style="margin-left:8px" @onclick="(()=>RemoveRelation(i))">?</button></li>
              }
            </ol>
          }
        </div>
      </div>

      <div class="sidebar-card">
        <h4>Model JSON</h4>
        <textarea class="json-area" @bind="modelJson"></textarea>
        <div class="action-row">
          <button class="control-btn" @onclick="ApplyImportedJson">Apply</button>
          <button class="control-btn" @onclick="ExportModel">Download</button>
        </div>
        <div class="footer-legend">Export/import model.json to persist or to feed generator.</div>
      </div>

    </div>
  </div>
</div>

@code {
    record FieldDef(string Name, string Type);
    record GraphEntity(string Name, List<FieldDef> Fields, double X, double Y);

    List<JsonElement>? rawEntities;
    List<GraphEntity> graphEntities = new();
    List<(string Source, string Target)> relations = new();
    string? selectedNodeName;
    List<JsonElement>? selectedColumns;
    string? modelJson;

    // drag state
    string? draggingNode;
    double dragOffsetX = 0;
    double dragOffsetY = 0;

    ElementReference canvasRef;
    ElementReference svgRef;

    private HubConnection? hub;

    protected override async Task OnInitializedAsync()
    {
        await LoadEntitiesFromApi();

        hub = new HubConnectionBuilder()
            .WithUrl(Nav.ToAbsoluteUri("/hubs/notifications"))
            .WithAutomaticReconnect()
            .Build();

        hub.On<Guid>("ProjectUpdated", async (_) =>
        {
            await LoadEntitiesFromApi();
            StateHasChanged();
        });

        try { await hub.StartAsync(); } catch { }
    }

    async Task LoadEntitiesFromApi()
    {
        try
        {
            rawEntities = await Http.GetFromJsonAsync<List<JsonElement>>(Nav.ToAbsoluteUri("api/Metadata/entities"));
            if (rawEntities == null) rawEntities = new List<JsonElement>();

            // map to GraphEntity with positions (grid)
            graphEntities.Clear();
            int col = 0, row = 0;
            const int gapX = 280, gapY = 180;
            foreach (var e in rawEntities)
            {
                var name = e.GetProperty("Name").GetString() ?? "Unknown";
                double x = 40 + (col * gapX);
                double y = 40 + (row * gapY);
                // increment grid
                col++;
                if (col > 2) { col = 0; row++; }

                // optionally if modelJson contains positions, honor them (we check modelJson parsed if set)
                List<FieldDef> fields = new();
                // try to get columns from entity JSON if present (optional)
                if (e.TryGetProperty("Columns", out var cols) && cols.ValueKind == JsonValueKind.Array)
                {
                    foreach (var c in cols.EnumerateArray())
                    {
                        var fname = c.GetProperty("Name").GetString() ?? "";
                        var ftype = c.GetProperty("Type").GetString() ?? "string";
                        fields.Add(new FieldDef(fname, ftype));
                    }
                }

                graphEntities.Add(new GraphEntity(name, fields, x, y));
            }

            // initial model json
            modelJson = JsonSerializer.Serialize(new { Entities = graphEntities.Select(g => new { Name = g.Name, X = g.X, Y = g.Y }), Relations = relations }, new JsonSerializerOptions { WriteIndented = true });
        }
        catch
        {
            rawEntities = new List<JsonElement>();
            graphEntities = new List<GraphEntity>();
        }
    }

    // pointer handlers for drag
    void OnNodePointerDown(Microsoft.AspNetCore.Components.Web.PointerEventArgs ev, string nodeName)
    {
        draggingNode = nodeName;
        // capture offset within node
        var ent = graphEntities.FirstOrDefault(x => x.Name == nodeName);
        if (ent is null) return;
        dragOffsetX = ev.ClientX - ent.X - canvasBoundingLeft;
        dragOffsetY = ev.ClientY - ent.Y - canvasBoundingTop;
    }

    double canvasBoundingLeft = 0;
    double canvasBoundingTop = 0;

    void OnPointerMove(Microsoft.AspNetCore.Components.Web.PointerEventArgs ev)
    {
        if (draggingNode == null) return;
        // compute canvas offset
        var rectTask = canvasRef.GetBoundingClientRectAsync(JS);
        rectTask.AsTask().ContinueWith(t =>
        {
            var rect = t.Result;
            canvasBoundingLeft = rect.Left;
            canvasBoundingTop = rect.Top;

            InvokeAsync(() =>
            {
                var ent = graphEntities.FirstOrDefault(x => x.Name == draggingNode);
                if (ent != null)
                {
                    ent = ent with { X = ev.ClientX - canvasBoundingLeft - dragOffsetX, Y = ev.ClientY - canvasBoundingTop - dragOffsetY };
                    // update list
                    var idx = graphEntities.FindIndex(x => x.Name == draggingNode);
                    if (idx >= 0) graphEntities[idx] = ent;
                    StateHasChanged();
                }
            });
        });
    }

    void OnPointerUp(Microsoft.AspNetCore.Components.Web.PointerEventArgs _)
    {
        draggingNode = null;
        // update model JSON
        modelJson = JsonSerializer.Serialize(new { Entities = graphEntities.Select(g => new { Name = g.Name, X = g.X, Y = g.Y }), Relations = relations }, new JsonSerializerOptions { WriteIndented = true });
    }

    // node click: either select or relation flow
    async Task OnNodeClick(string nodeName)
    {
        if (addRelationMode)
        {
            if (relationSource == null)
            {
                relationSource = nodeName;
                SnackbarMessage($"Relation source set: {relationSource}");
            }
            else if (relationSource == nodeName)
            {
                // clicked same, cancel
                relationSource = null;
                SnackbarMessage("Relation cancelled");
            }
            else
            {
                relations.Add((relationSource, nodeName));
                relationSource = null;
                addRelationMode = false;
                modelJson = JsonSerializer.Serialize(new { Entities = graphEntities.Select(g => new { Name = g.Name, X = g.X, Y = g.Y }), Relations = relations }, new JsonSerializerOptions { WriteIndented = true });
            }
            StateHasChanged();
            return;
        }

        // select node
        selectedNodeName = nodeName;
        selectedColumns = null;
        // try fetch columns automatically (non-blocking)
        await LoadColumnsForSelected();
        StateHasChanged();
    }

    string? relationSource;
    bool addRelationMode = false;

    void ToggleAddRelation()
    {
        addRelationMode = !addRelationMode;
        relationSource = null;
    }

    void SnackbarMessage(string message)
    {
        // simple temporary visual hint: use JS alert minimally
        // but we keep it silent to not spam; could integrate MudSnackbar via DI if desired
        Console.WriteLine(message);
    }

    async Task LoadColumnsForSelected()
    {
        if (string.IsNullOrEmpty(selectedNodeName)) return;
        try
        {
            selectedColumns = await Http.GetFromJsonAsync<List<JsonElement>>(Nav.ToAbsoluteUri($"api/Metadata/entity/{selectedNodeName}/columns"));
        }
        catch
        {
            selectedColumns = null;
        }
    }

    void AddEntity()
    {
        var name = $"NewEntity{graphEntities.Count + 1}";
        graphEntities.Add(new GraphEntity(name, new List<FieldDef>(), 40 + graphEntities.Count * 30, 40 + (graphEntities.Count % 3) * 160));
        modelJson = JsonSerializer.Serialize(new { Entities = graphEntities.Select(g => new { Name = g.Name, X = g.X, Y = g.Y }), Relations = relations }, new JsonSerializerOptions { WriteIndented = true });
    }

    void DeleteSelectedEntity()
    {
        if (string.IsNullOrEmpty(selectedNodeName)) return;
        graphEntities.RemoveAll(x => x.Name == selectedNodeName);
        relations.RemoveAll(r => r.Source == selectedNodeName || r.Target == selectedNodeName);
        selectedNodeName = null;
        modelJson = JsonSerializer.Serialize(new { Entities = graphEntities.Select(g => new { Name = g.Name, X = g.X, Y = g.Y }), Relations = relations }, new JsonSerializerOptions { WriteIndented = true });
    }

    void ClearRelations()
    {
        relations.Clear();
        modelJson = JsonSerializer.Serialize(new { Entities = graphEntities.Select(g => new { Name = g.Name, X = g.X, Y = g.Y }), Relations = relations }, new JsonSerializerOptions { WriteIndented = true });
    }

    void RemoveRelation(int index)
    {
        if (index >= 0 && index < relations.Count) relations.RemoveAt(index);
    }

    (double X, double Y) GetCenter((string Source, string Target) r) => GetCenter(r.Source); // convenience

    (double X, double Y) GetCenter(string name)
    {
        var ent = graphEntities.FirstOrDefault(x => x.Name == name);
        if (ent == null) return (0, 0);
        // node width ~ 220, height ~ approx 100; compute center
        return (ent.X + 110, ent.Y + 38);
    }

    void ResetPositions()
    {
        // arrange in grid
        int col = 0, row = 0;
        const int gapX = 280, gapY = 180;
        for (int i = 0; i < graphEntities.Count; i++)
        {
            graphEntities[i] = graphEntities[i] with { X = 40 + col * gapX, Y = 40 + row * gapY };
            col++;
            if (col > 2) { col = 0; row++; }
        }
        modelJson = JsonSerializer.Serialize(new { Entities = graphEntities.Select(g => new { Name = g.Name, X = g.X, Y = g.Y }), Relations = relations }, new JsonSerializerOptions { WriteIndented = true });
    }

    async Task ExportModel()
    {
        var exportObj = new
        {
            Entities = graphEntities.Select(g => new { g.Name, g.Fields, g.X, g.Y }),
            Relations = relations
        };
        var json = JsonSerializer.Serialize(exportObj, new JsonSerializerOptions { WriteIndented = true });
        await JS.InvokeVoidAsync("archocyboDownload", $"model-{DateTime.UtcNow:yyyyMMddHHmm}.json", json);
    }

    void ImportModelPrompt()
    {
        // open prompt to paste JSON into textarea -- user can paste then click Apply
        // set modelJson to current string (user can replace it)
        modelJson = JsonSerializer.Serialize(new { Entities = graphEntities.Select(g => new { g.Name, g.Fields, g.X, g.Y }), Relations = relations }, new JsonSerializerOptions { WriteIndented = true });
    }

    void ApplyImportedJson()
    {
        try
        {
            var doc = JsonDocument.Parse(modelJson ?? "");
            if (doc.RootElement.TryGetProperty("Entities", out var ents) && ents.ValueKind == JsonValueKind.Array)
            {
                graphEntities = new List<GraphEntity>();
                foreach (var el in ents.EnumerateArray())
                {
                    var name = el.GetProperty("Name").GetString() ?? "e";
                    double x = el.TryGetProperty("X", out var px) && px.TryGetDouble(out var dx) ? dx : 40;
                    double y = el.TryGetProperty("Y", out var py) && py.TryGetDouble(out var dy) ? dy : 40;
                    var fields = new List<FieldDef>();
                    if (el.TryGetProperty("Fields", out var farr) && farr.ValueKind == JsonValueKind.Array)
                    {
                        foreach (var f in farr.EnumerateArray())
                        {
                            var fname = f.GetProperty("Name").GetString() ?? "";
                            var ftype = f.GetProperty("Type").GetString() ?? "string";
                            fields.Add(new FieldDef(fname, ftype));
                        }
                    }
                    graphEntities.Add(new GraphEntity(name, fields, x, y));
                }
            }

            relations.Clear();
            if (doc.RootElement.TryGetProperty("Relations", out var rels) && rels.ValueKind == JsonValueKind.Array)
            {
                foreach (var r in rels.EnumerateArray())
                {
                    var s = r.GetProperty("Source").GetString();
                    var t = r.GetProperty("Target").GetString();
                    if (!string.IsNullOrEmpty(s) && !string.IsNullOrEmpty(t)) relations.Add((s, t));
                }
            }

            StateHasChanged();
        }
        catch
        {
            // ignore parse errors
        }
    }

    public async ValueTask DisposeAsync()
    {
        if (hub != null)
        {
            try { await hub.StopAsync(); } catch { }
            await hub.DisposeAsync();
        }
    }
}

@code {
    // small helper to get bounding client rect via JS (Blazor doesn't expose directly in .NET)
    // We're using the built-in IJSRuntime extension to get element rect (via a tiny JS helper below)
}

<script>
  window.archocyboDownload = function (filename, content) {
    const blob = new Blob([content], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = filename;
    a.click();
    URL.revokeObjectURL(url);
  };

  // helper to retrieve bounding rect
  window.getBoundingClientRect = (el) => {
    if (!el) return null;
    const r = el.getBoundingClientRect();
    return { left: r.left, top: r.top, width: r.width, height: r.height };
  };

  // Blazor extension to call from element references:
  // canvasRef.GetBoundingClientRectAsync(JS) is implemented by the runtime as:
  // JS.InvokeAsync<Object>("getBoundingClientRect", element)
</script>
